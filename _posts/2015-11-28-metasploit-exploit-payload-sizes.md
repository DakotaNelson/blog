---
layout: post
title: "Stagers, and Metasploit Payload Size"
date: 2015-11-28 12:00
authors: [dakota]
description: By analyzing the exploits available as part of the Metasploit Project, we can draw some interesting conclusions about the payload size in exploits, and apply those conclusions to the design of stagers and other exploit payloads.
tags: [security, cybersecurity, Metasploit, stager]
---

{% assign author = site.authors[page.author] %}

#### Or: How big can my stagers be, really?

The idea here is to parse through the [Metasploit Project](https://github.com/rapid7/metasploit-framework)'s available exploits to determine what the distribution of payload sizes is, with an eye to deciding whether that super cool stager idea you had the other day is worth pursuing.

If you're familiar with the concepts of vulnerabilities, exploits, and stagers, go ahead and skip to the graphs below. Otherwise, read on:

Certain specific types of software bugs can lead to what are known as vulnerabilities - situations which can be exploited to cause the software to fail in specific ways. While it's more common to be able to cause the software to simply crash, certain vulnerabilities can lead to what's known as arbitrary code execution - which is exactly what it sounds like, allowing anyone who is able to exploit that vulnerability to execute whatever commands they wish on the machine running the vulnerable software.

In keeping with the terms above, a "vulnerability" is a situation which could lead to a problem, if someone figures out how to take advantage of it, and an "exploit" is a piece of software which takes advantage of a vulnerability - exploits it, as it were.

However, in most cases exploits can't simply run anything they want - the specific bug they take advantage of forces them to have a size limit, only allowing a certain amount of data (code) to be arbitrarily executed by the vulnerable host. This has led to the advent of stagers, small stubs of code which exist to reach out and retrieve a larger, more fully-featured piece of code which is then used to accomplish whatever the attacker has in mind now that they control the system. Since the usefulness of a stager is limited by its ability to fit into the small amount of space that many exploits have available, most are handwritten in assembly to ensure they are as small as possible.

So, with that in mind - this post explores the payload space in the exploits available as a part of the [Metasploit Project](https://github.com/rapid7/metasploit-framework), a large, publicly-accessible offensive security tool, with the assumption that these are reasonably representative of exploits in general.

This can help make decisions for stager size optimization - if I have a great idea for a stager (or other exploit payload), but can't make it any smaller than 1k, is it worth it? What if it's 2k? And so on.

**As it turns out, payloads over 2kb work with less than 20% of available exploits, and payloads over 1kb only work with about 60% - if you can't make your stager under 2k, you shouldn't expect to be able to use it very often at all.**

Let's dive right in with some graphs:

{:.center}
![Cumulative Distribution of Payload Size]({{site.url}}/assets/exploitSize1.png){: .image }

This is a fairly simple view on the data: plot each exploit against its payload space. To interpret this, imagine that at any point on the x axis, that module, and every module to the right of it, will work for the given y value (payload size) or less.

{:.center}
![Distribution of Payload Size]({{site.url}}/assets/exploitSize2.png){: .image }

This second view is a lot more useful, as it displays the payload size against the fraction of exploits which will work (or not work) for that size. It looks like any payload over 2048 bytes will only work with about 20% of exploits - a little less, in fact! If any of your stagers are just barely above 1024 bytes, it's well worth the effort to trim those last few bytes. Almost a quarter of exploits available in Metasploit have a payload size cutoff at 1024 bytes.

The three vertical lines serve to highlight these major cutoff points - they're at 512, 1024, and 2048 bytes.

This chart can also be read as a probability: if I want to send a 1000 byte payload, and I pick an exploit at random (or, I find a vulnerable host at random), I have about a 60% chance that the exploit I end up with will be able to accomodate that payload. If my payload is 500 bytes, that probability becomes more than 90%.

{:.center}
![Histogram of Exploit Payload Sizes]({{site.url}}/assets/exploitSize3.png){: .image }

The humble histogram finishes out our exploration today - note that it's on a log scale. This is significantly less useful than the above charts, since payload size is a cumulative number (i.e. smaller payloads still work in exploits with more than enough space for them), but this view is interesting in that it shows us where there are large clusters of exploits accepting a certain payload size.

If you'd like to see the raw data, code, and analysis, you can find it on [Github](https://github.com/DakotaNelson/msf-stats/blob/master/Exploit%20Payload%20Sizes.ipynb).
